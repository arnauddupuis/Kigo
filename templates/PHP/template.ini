# Types are the types provided by this template. In this case we have:
# class: this is the template for a basic PHP class that accesses data in a SQL database.
# script: a PHP script that does something (anything)
# api: the frontend web API
types=class,script,api

# A template can require another template to work as intended. The "use" keyword tell kigo this information. As types, it is a coma separated list.
use=SQL

# All generated files can have a prefix to help identify them (but it is obviously not mandatory)
prefix:class=C
prefix:script=s_
prefix:api=api_

# include for a specific type
# include:WebConfig=WebConfig.php

# output:root is where kigo will put the generated files. You can generate a proper hierarchy by using the output:<specific> notation.
# Generic output root dir for this template
output:root=generated_php
# Specific output directories. They are all relative to the output:root directory. If they are left empty or not defined the following default values applies :
# output:class=/class
# output:script=/script
# output:api=/api
# By default if a type doesn't have an output directory defined, kigo will generate a rule that will have the following form: output:<type>=/<type>.
output:class=/class
output:script=/scripts
output:api=/api
# If you want/need everything to be put in the same directory just write rules that looks like that: output:<type>=/ (for each types).

# Extra includes you want to put in all generated files (you want to use that after thinking twice to the implications...).
extra_includes=

# Here are the description of the template architecture (if you copy this template to create a new one, this part is not needed as this template is only filled with default values).
class:main_template=class.ktpl
class:getter=getter.ktpl
class:setter=setter.ktpl
script:main_template=script.ktpl
api:main_template=api.ktpl

# Variables prefixed by "keyword" represents the keywords language adaptation
keyword:inheritance=extends
